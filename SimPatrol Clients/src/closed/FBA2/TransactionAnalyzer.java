package closed.FBA2;

import java.awt.Color;
import java.io.IOException;
import java.util.LinkedList;

import closed.FBA.SpeechAct;
import closed.FBA.SpeechActPerformative;


import util.CurveViewer;
import util.file.FileReader;


/**
 * Transaction Analyzer
 * 
 * This class aims at providing some tools to analyze the flow of transactions 
 * during a simulation, as it is very difficult to do it by hand.
 * 
 * It uses the log file generated by SimPatrol as base.
 * 
 * @author pouletc
 *
 */
public class TransactionAnalyzer {
	
	public LinkedList<CompleteTransaction> transactions;
	public int nb_messages = 0;

	
	public TransactionAnalyzer(){
		transactions = new LinkedList<CompleteTransaction>();
	}
	
	/**
	 * Parsers
	 * 
	 * @param args
	 * @throws IOException 
	 */
	
	public void ReadDoc_closedSystem(String path, int nb_agents) throws IOException{
		
		transactions.clear();
		
		FileReader myFile = new FileReader(path);
		
		while(!myFile.isEndOfFile()){
			
			String line = myFile.readLine();
			
			if (line.indexOf("<event type=\"8\"") > -1 || line.indexOf("<event type=\"9\"") > -1) {
				if(line.indexOf("<event type=\"9\"") > -1)
					nb_messages++;
				
				if(line.indexOf("ACT") == -1)
					continue;
				String time_str = line.substring(line.indexOf("time=\"") + 6);
				time_str = time_str.substring(0, time_str.indexOf("."));
				int time = Integer.valueOf(time_str);
				String message = line.substring(line.indexOf("message=\"")+ 9, line.lastIndexOf("\"/>"));
				SpeechAct received_act = SpeechAct.fromString(message);		
				
				boolean added = false;
				for(CompleteTransaction myTrans: transactions)
					if(myTrans.trans_id == received_act.getTransactionId()){
						myTrans.addAct(received_act, time);
						added = true;
					}
				
				if(!added){
					CompleteTransaction newTrans = new CompleteTransaction(received_act.getTransactionId(), time, nb_agents);
					newTrans.addAct(received_act, time);
					transactions.add(newTrans);
				}
			}
		}
		
		myFile.close();
	}
	
	public void ReadDoc_openSystem(String path) throws IOException{
		
		transactions.clear();
		
		FileReader myFile = new FileReader(path);
		
		while(!myFile.isEndOfFile()){
			
			String line = myFile.readLine();
			
			if (line.indexOf("<event type=\"8\"") > -1 || line.indexOf("<event type=\"9\"") > -1) {
				if(line.indexOf("<event type=\"9\"") > -1)
					nb_messages++;
				
				if(line.indexOf("ACT") == -1)
					continue;
				String time_str = line.substring(line.indexOf("time=\"") + 6);
				time_str = time_str.substring(0, time_str.indexOf("."));
				int time = Integer.valueOf(time_str);
				String message = line.substring(line.indexOf("message=\"")+ 9, line.lastIndexOf("\"/>"));
				SpeechAct received_act = SpeechAct.fromString(message);		
				
				boolean added = false;
				for(CompleteTransaction myTrans: transactions)
					if(myTrans.trans_id == received_act.getTransactionId()){
						myTrans.addAct(received_act, time);
						added = true;
					}
				
				if(!added){
					CompleteTransaction newTrans = new CompleteTransaction(received_act.getTransactionId(), time);
					newTrans.addAct(received_act, time);
					transactions.add(newTrans);
				}
			}
		}
		
		myFile.close();
	}
	
	
	
	/**
	 * Analyzes all transactions.
	 * If is_normal...() returns false, it prints whatIsWrong...()
	 * 
	 */
	public void Analyze_closedSystem(){
		for(int i = 0; i < transactions.size(); i++)
			if(!transactions.get(i).isNormal_closedSystem()){
				System.out.println(transactions.get(i).whatIsWrong_closedSystem());
				System.out.println(transactions.get(i).toString());
			}
	}
	
	public void Analyze_openSystem(){
		for(int i = 0; i < transactions.size(); i++)
			if(!transactions.get(i).isNormal_openSystem()){
				System.out.println(transactions.get(i).whatIsWrong_openSystem());
				System.out.println(transactions.get(i).toString());
			}
	}
	
	/**
	 * prints the nb of transactions, and prints every transaction in the log
	 */
	public void FullAnalysis(){
		System.out.println("Nb of transactions : " + transactions.size());
		for(int i = 0; i < transactions.size(); i++){
			CompleteTransaction trans = transactions.get(i);
			System.out.println(trans.toString());
		}
	}
	
	/**
	 * prints every transaction in the log containing the string @param s (it can be a node id, an agent id, etc.)
	 */
	public void FullAnalysis(String s){
		int nbtrans = 0;
		for(int i = 0; i < transactions.size(); i++){
			CompleteTransaction trans = transactions.get(i);
			if(trans.toString().contains(s)){
				nbtrans++;
				System.out.println(trans.toString());
			}
		}
		System.out.println("Nb de transactions : " + nbtrans + "/" + transactions.size());
	}
	
	/**
	 * prints every transaction in the log containing the node id @param s
	 */
	public void FullAnalysisByNode(String s){
		for(int i = 0; i < transactions.size(); i++){
			CompleteTransaction trans = transactions.get(i);
			if(trans.toString().contains(s + ';') || trans.toString().contains(s + '('))
					System.out.println(trans.toString());
		}
	}
	
	/**
	 * tracks the ownership of node @param nodeName through the simulation
	 * @param nodeName
	 */
	public void AnalyseOwnership(String nodeName){
		LinkedList<String> owners = new LinkedList<String>();
		
		for(int i = 0; i < transactions.size(); i++){
			CompleteTransaction trans = transactions.get(i);
			for(SpeechAct act : trans.acts)
				if((act.getPerformative() == SpeechActPerformative.INFORM || act.getPerformative() == SpeechActPerformative.PROPOSE ) && 
						(act.toString().contains(nodeName + ';') || act.toString().contains(nodeName + '('))){
					owners.add(act.getSender());
					break;
				}
			if(owners.size() > 0)
				break;
		}
		
		for(int i = 0; i < transactions.size(); i++){
			CompleteTransaction trans = transactions.get(i);
			for(SpeechAct act : trans.acts)
				if(act.getPerformative() == SpeechActPerformative.ACCEPT && 
						(act.toString().contains(nodeName + ";") || act.toString().contains(nodeName + "("))){
					String send = act.getSender();
					if(!owners.getLast().equals(send))
						owners.add(send);
					else
						owners.add(act.getReceiver());
					
					
				}
		}
		
		System.out.println("Ownership for node " + nodeName + " : ");
		System.out.print(owners.get(0));
		for(int i = 1; i < owners.size(); i++)
			System.out.print(" -> " + owners.get(i));
		System.out.print("\n");
				
	}
	
	/**
	 * returns the distribution of the number of transaction as a list of double that can be used in a util.CurveViewer
	 * 
	 * only the transactions concluded are counted, and they are counted at the time of conclusion
	 * 
	 * @param start : starting time
	 * @param stop : stop time
	 * @param freq : frequency
	 * @param open : is the system open or not ? 
	 * @return
	 */
	public Double[] getTransactionDistribution(int start, int stop, int freq, boolean open){
		Double[] distribution = new Double[(stop - start)/freq + (((stop - start)%freq == 0)? 0 : 1)];
		for(int i = 0; i < distribution.length; i++)
			distribution[i] = 0d;
		
		for(int i = 0; i < this.transactions.size(); i++){
			CompleteTransaction transac = this.transactions.get(i);
			boolean isconcluded = (open? transac.isConcluded_openSystem() : transac.isConcluded_closedSystem());
			if(isconcluded && transac.getAcceptationTime() >= start && transac.getAcceptationTime() < stop)
				distribution[(int)((transac.getAcceptationTime() - start) / freq)]++;
		}
		
		return distribution;
	}
	
	
	/**
	 * this is only an exemple of use
	 * @param args
	 */
	public static void main(String[] args) {
		TransactionAnalyzer analyzer = new TransactionAnalyzer();
		
		try {
			analyzer.ReadDoc_closedSystem("/home/pouletc/experimentation/Simulations/mapA/0_5_4_open/logs_OpenFBANodes/log_0.txt", 5);
		} catch (IOException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
		//analyzer.Analyze();
		//analyzer.AnalyseOwnership("v25");
		//analyzer.FullAnalysisByNode("v25");
		int freq = 10;
		Double[] myfreq = new Double[2999/freq +1];
		for(int i = 0; i < myfreq.length; i++)
			myfreq[i] = (double) i * freq;
		Double[] my_distrib = analyzer.getTransactionDistribution(0, 2999, 10, false);
		
		CurveViewer myviewer = new CurveViewer("exchanges");
		myviewer.addCurve(myfreq, my_distrib, Color.blue);
		myviewer.setXdivision(100);
		myviewer.setYdivision(1);
		myviewer.setVisible(true);
	}

}


/**
 * This class represents a complete transaction, by aggregating all the messages with the same transaction Id
 * 
 * Each function exists in the closed system version (the number of agents is known and can be used to control that 
 * the right number of messages have been exchanged) and in the open system version (the number of agents is unknown and 
 * all that can be controlled is that there is only one INFORM and that every PROPOSE has been answered by an ACCEPT or a REJECT)
 * 
 * 
 * @author pouletc
 *
 */
final class CompleteTransaction {
	
	public LinkedList<SpeechAct> acts;
	public LinkedList<Integer> acts_time;
	
	public int trans_id;
	public int nb_agents;
	public int creation_time;
	private int acceptation_time = -1;
	
	public int nb_inform = 0;
	public int nb_reject = 0;
	public int nb_propose = 0;
	public int nb_refuse = 0;
	public int nb_accept = 0;
	public int nb_not_understood = 0;
	
	public CompleteTransaction(int trans_id, int creation_time, int nb_agents){
		this.trans_id = trans_id;
		this.nb_agents = nb_agents;
		this.creation_time = creation_time;
		acts = new LinkedList<SpeechAct>();
		acts_time = new LinkedList<Integer>();
	}
	
	public CompleteTransaction(int trans_id, int creation_time){
		this.trans_id = trans_id;
		this.creation_time = creation_time;
		acts = new LinkedList<SpeechAct>();
	}
	
	public void addAct(SpeechAct act, int time){
		for(SpeechAct existingAct : acts)
			if(existingAct.equals(act))
				return;
		acts.add(act);
		acts_time.add(time);
		
		switch(act.getPerformative()){
			case INFORM :
				nb_inform++;
				break;
			case REJECT :
				nb_reject++;
				break;
			case PROPOSE :
				nb_propose++;
				break;
			case REFUSE :
				nb_refuse++;
				break;
			case ACCEPT :
				nb_accept++;
				acceptation_time = time;
				break;
			case NOT_UNDERSTOOD :
				nb_not_understood++;
				break;		
		}
	}
	
	/**
	 * 
	 * @return
	 */
	public boolean isNormal_closedSystem(){
		boolean normal = true;
		
		normal = (nb_inform == 1) && 
					(nb_refuse + nb_propose == nb_agents - 1) && 
					((nb_refuse == nb_agents - 1) || ((nb_reject + nb_accept == nb_propose) && (nb_accept <= 1))) && 
					(nb_not_understood == 0);
		
		return normal;
	}
	
	public boolean isNormal_openSystem(){
		boolean normal = true;
		normal = (nb_inform == 1) && ((nb_reject + nb_accept == nb_propose) && (nb_accept <= 1)) && (nb_not_understood == 0);
		
		return normal;
	}
	
	public String whatIsWrong_closedSystem(){
		String wrong = "Transaction #" + this.trans_id + " (time " + this.creation_time + "): ";
		if(nb_inform != 1)
			if(nb_inform ==0)
				wrong += "No INFORM message; ";
			else
				wrong += "too much INFORM messages (" + this.nb_inform + "); ";
		
		if(nb_refuse + nb_propose != nb_agents - 1)
			if(nb_refuse + nb_propose < nb_agents - 1)
				wrong += "Too few answers (" + this.nb_propose + " propose, " + this.nb_refuse + " refuse); ";
			else
				wrong += "Too many answers (" + this.nb_propose + " propose, " + this.nb_refuse + " refuse); ";
		
		if((nb_refuse != nb_agents - 1) && ((nb_reject + nb_accept != nb_propose) || (nb_accept > 1))){
			wrong += "Closing problem : ";
			if((nb_refuse != nb_agents - 1)){
				if(nb_reject + nb_accept != nb_propose)
					wrong += "Too few decisions (" + this.nb_reject + " reject, " + this.nb_accept + " accept for " + this.nb_propose + " propose); ";
				else
					wrong += "Too much accept ( " + this.nb_accept + "); ";
			}
			else
				wrong += "No accept and too few refuse (" + this.nb_refuse + "); ";
		}
		
		return wrong;
		
	}
	
	public String whatIsWrong_openSystem(){
		String wrong = "Transaction #" + this.trans_id + " (time " + this.creation_time + "): ";
		if(nb_inform != 1)
			if(nb_inform ==0)
				wrong += "No INFORM message; ";
			else
				wrong += "too much INFORM messages (" + this.nb_inform + "); ";
		
		if((nb_reject + nb_accept != nb_propose) || (nb_accept > 1)){
			wrong += "Closing problem : ";
			if(nb_reject + nb_accept != nb_propose)
				wrong += "Too few decisions (" + this.nb_reject + " reject, " + this.nb_accept + " accept for " + this.nb_propose + " propose); ";
			else
				wrong += "Too much accept ( " + this.nb_accept + "); ";
		}
		
		return wrong;
		
	}
	
	public String toString(){
		String str = "Transaction #" + this.trans_id + " (time " + this.creation_time + "): \n";
		for(int i = 0; i < acts.size(); i++)
			str += "    " + acts.get(i).toString() + "\n";
		
		return str;
	}
	
	
	/**
	 * returns true if there was at least one ACCEPT
	 * @return
	 */
	public boolean isConcluded_closedSystem(){
		return (nb_accept >= 1);
	}
	
	/**
	 * returns true if isNormal_openSystem returns true
	 * @return
	 */
	public boolean isConcluded_openSystem(){
		return isNormal_openSystem();
	}
	
	
	/**
	 * returns the time of the ACCEPT message if it exists, of the time of the last message in the transaction
	 * @return
	 */
	public int getAcceptationTime(){
		if(this.acceptation_time != -1)
			return this.acceptation_time;
		
		for(int i = 0; i < acts_time.size(); i++)
			if(acts_time.get(i) > this.acceptation_time)
				this.acceptation_time = acts_time.get(i);
		
		return this.acceptation_time;
			
	}
	
	
	
}
