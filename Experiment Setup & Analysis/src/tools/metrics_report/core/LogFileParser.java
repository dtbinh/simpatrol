package tools.metrics_report.core;

import java.io.FileNotFoundException;
import java.io.FileReader;
import java.io.IOException;
import java.util.HashMap;
import java.util.Map;

import util.DoubleList;

import com.twicom.qdparser.DocHandler;
import com.twicom.qdparser.QDParser;
import com.twicom.qdparser.XMLParseException;


/**
 * Parser for the file generated by the logger client of the SimPatrol. 
 * 
 * It parses the XML file and returns the visits information as an object
 * of the class VisitsList, which can be used to calculate any metrics.
 * 
 * @author Pablo A. Sampaio
 */
public class LogFileParser implements DocHandler {
	private HashMap<String,Integer> agentsNumbers;
	private HashMap<String,Integer> nodesNumbers;
	private HashMap<String,Integer> agentsNodes; 

	private int numAgents;
	private int numNodes;
	private VisitsList visits;
	private DoubleList nodePriorities;
	private int lastCycle;
	
	private boolean verbose;
	
	
	public LogFileParser() {
		reset();
		this.verbose = false;
	}
	
	public LogFileParser(boolean showMessages) {
		reset();
		this.verbose = showMessages;
	}
	
	private void reset() {
		this.agentsNumbers = new HashMap<String, Integer>();
		this.nodesNumbers = new HashMap<String,Integer>();
		this.agentsNodes  = new HashMap<String,Integer>();
		
		this.nodePriorities = new DoubleList();
		
		this.numAgents = 0;
		this.numNodes = 0;
		this.lastCycle = 0;
		this.visits = new VisitsList();
	}
	
	public int getLastCycle() {
		return lastCycle;
	}


	@Override
	public void startDocument() throws XMLParseException {
	}

	@Override
	public void endDocument() throws XMLParseException {
	}

	@Override
	public synchronized void startElement(String nameSpace, String tag,
			Map<String, String> attributes, int line, int col)
			throws XMLParseException {
		
		if (tag.equals("node")) {
			String node = attributes.get("id");
			
			// associates the node to an unique number
			if(! nodesNumbers.containsKey(node)){
				nodesNumbers.put(node, numNodes);
				numNodes ++;
			}
			
			// stores each node's priority value
			this.nodePriorities.add(Double.parseDouble(attributes.get("priority")));
			
			myPrintf("Node %s is number %d.", node, nodesNumbers.get(node));

		} else if (tag.equals("agent")) {
			String agentId = attributes.get("id");
			
			// associates the agent to an unique number (among agents)
			if(!this.agentsNumbers.containsKey(agentId)){
				this.agentsNumbers.put(agentId, this.numAgents);
				this.numAgents ++;
			}
			
			myPrintf("Agent %s is number %d.", agentId, agentsNumbers.get(agentId));
			
			// TODO: REMOVE THIS by referencing the node directly in event 6
			
			String nodeId  = attributes.get("node_id");
			Integer nodeNumber = this.nodesNumbers.get(nodeId);
			
			this.agentsNodes.put(agentId, nodeNumber);
			myPrintf("Agent %d (%s) starts in node %d (%s).", numAgents-1, agentId, nodeNumber, nodeId);

		} else if (tag.equals("event") ) {
			
			if (attributes.get("type").equals("6")) {
				String agentId = attributes.get("agent_id");
				
				int agent = this.agentsNumbers.get(agentId);
				int node  = this.agentsNodes.get(agentId);
				int time  = (int)Double.parseDouble( attributes.get("time") );
				
				visits.addVisit(new Visit(time, agent, node));
				
				myPrintf(">> Agent %d visited node %d in time %d!", agent, node, time);
			
			} else if (attributes.get("type").equals("5")) {
				// REMOVE THIS by including the node directly in event 6

				String agent = attributes.get("agent_id");
				String node  = attributes.get("node_id");
				Integer nodeNumber = this.nodesNumbers.get(node);
					
				this.agentsNodes.put(agent, nodeNumber);
				myPrintf("Agent %s is in node %d (%s).", agent, nodeNumber, node);

			} else if (attributes.get("type").equals("2")) {
				int time  = (int)Double.parseDouble( attributes.get("time") );
				if (this.lastCycle < time) {
					myPrintf("Last cycle: %s", time);
					this.lastCycle = time;
				}
			} 
			
		}
		
	}

	@Override
	public void endElement(String nameSpace, String tag)
			throws XMLParseException {
	}

	@Override
	public void text(String str, int line, int col) throws XMLParseException {
	}

	@Override
	public void text(String str, boolean cdata, int line, int col)
			throws XMLParseException {
	}
	
	public void parseFile(String fileName) throws FileNotFoundException, XMLParseException, IOException {
		reset();		
		QDParser.parse(this, new FileReader(fileName));
	}
	
	public VisitsList getVisitsList() {
		return visits;
	}
	
	public int getNumAgents() {
		return numAgents;
	}
	
	public int getNumNodes() {
		return numNodes;
	}

	public DoubleList getNodePriorities() {
		return nodePriorities;
	}
	
	public void myPrintf(String msg, Object... args) {
		if (this.verbose) {
			System.out.printf("PARSER: " + msg + "\n", args);
		}
	}
	
}
